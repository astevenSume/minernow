package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"sort"
	"strconv"
)

//error code enum
const (
	ERROR_FILE = "errors.go"
	MD_FILE    = "md.txt"
)

var (
	OUT_PATH    string
	CONFIG_PATH string
)

type MapErrCode map[string]map[string]string

func main() {
	flag.StringVar(&OUT_PATH, "out-dir", "./", "error.go file path")
	flag.StringVar(&CONFIG_PATH, "config", "./config.json", "config.json path")
	flag.Parse()

	langMap := make(map[string]bool)

	var codeMap = make(MapErrCode, 0)
	data, err := ioutil.ReadFile(CONFIG_PATH)
	if err != nil {
		fmt.Printf("read file %s failed : %v", CONFIG_PATH, err)
		return
	}
	// to map
	err = json.Unmarshal(data, &codeMap)
	if err != nil {
		fmt.Println(data)
		fmt.Println("json parse failed! please check the configuration.")
		return
	}

	config, haveConfig := codeMap["config"]
	if haveConfig {
		delete(codeMap, "config")
		if _, ok := config["package"]; !ok {
			config["package"] = "controllers"
		}
		if _, ok := config["need_response_func"]; !ok {
			config["need_response_func"] = "1"
		}
		if _, ok := config["md"]; !ok {
			config["md"] = ""
		}
	} else {
		config = map[string]string{
			"package":            "controllers",
			"need_response_func": "1",
			"md":                 "",
		}
	}

	//output for markdown file
	mdContent := `| 错误码 | 描述 | 备注 |
| :------ | :------ | :------ |	`

	content := `package ` + config["package"] + `
//this code is generated by tools/errorgenerater automatically, don't try to modify it manually !
`
	if config["need_response_func"] == "1" {
		content += `
import (
	"fmt"
    "github.com/astaxie/beego/context"
)
`
	}

	ids := sort.IntSlice{}
	id2detail := map[int]string{}

	msgs := make(map[string]map[string]string)

	//mdMsgs := make(map[string]map[string]string)

	for k, v := range codeMap {
		var id string
		msg := make(map[string]string)
		for k1, v1 := range v {
			if k1 == "id" {
				id = v1

				if i, err := strconv.ParseInt(k, 10, 32); err == nil {
					ids = append(ids, int(i))
					id2detail[int(i)] = id
				}
			} else {
				msg[k1] = v1
				langMap[k1] = true
			}
		}

		if _, ok := msgs[id]; !ok {
			msgs[id] = make(map[string]string)
		}
		for l, m := range msg {
			msgs[id][l] = m
		}
	}

	//lang sort
	langSort := sort.StringSlice{}
	for k, _ := range langMap {
		langSort = append(langSort, k)
	}
	langSort.Sort()

	if len(langSort) > 0 {
		content += `var mapLanguages = map[string]bool{
`
		for _, lang := range langSort {
			content += fmt.Sprintf("\t\"%s\": true,\n", lang)
		}
		content += `}

// @Description check if support specific language 
func CheckLanguage(lang string) bool {
    if _, ok := mapLanguages[lang]; ok {
        return true
    } else {
        return false
    }
}

// @Description return error message
func ErrorMsg(code ERROR_CODE, lang string)string{
    if _, ok := mapMsgs[code]; ok {
        if _, ok = mapMsgs[code][lang]; ok{
             return mapMsgs[code][lang]
        } else {
             return mapMsgs[ERROR_CODE_UNKNOWN][lang]
        }
    } else {
        return mapMsgs[ERROR_CODE_UNKNOWN][lang]
    }
}

`
	}
	ids.Sort()

	if len(msgs) > 0 {

		content += `//error code defination
type ERROR_CODE int

const (
`
		for _, i := range ids {
			id := id2detail[i]
			content += fmt.Sprintf("\tERROR_CODE_%-30s ERROR_CODE = %d\n", id, i)
		}
		content += `)
`

		content += `var mapMsgs = map[ERROR_CODE]map[string]string {
`
		for _, i := range ids {
			id := id2detail[i]
			if list, ok := msgs[id]; ok {
				msgTmp := ""
				content += fmt.Sprintf("ERROR_CODE_%s : {\n", id)
				for _, key := range langSort {
					if val, ok2 := list[key]; ok2 {
						content += fmt.Sprintf("\t\t\"%s\" : \"%s\",\n", key, val)
						msgTmp += fmt.Sprintf("%s : %s<br>", key, val)
					}
				}
				content += `    }, `

				mdContent += fmt.Sprintf("\n| %d | %s | %s |", i, id, msgTmp)
			}
		}
	}

	content += `
}`

	responseFunc := `
// @Description error response
func ERROR_CODE_RESPONSE(code ERROR_CODE, ctx *context.Context) {
    //get "lang" from context, default is "en"
    var lang string
    if v := ctx.Input.Header("lang"); v != "" {
		lang = v
	} else {
        lang = "en"    
    }

    msg := ErrorMsg(code, lang)
    if len(msg) > 0 {
        ctx.ResponseWriter.Write([]byte(fmt.Sprintf("{\"code\":%d, \"msg\":\"%s\"}", code, msg)))
    }else {
        ctx.ResponseWriter.Write([]byte(fmt.Sprintf("{\"code\": %d}", code)))
    }
}

// @Description error response with result
func ERROR_CODE_RESPONSE_WITH_RESULT(code ERROR_CODE, result interface{}, ctx *context.Context) {
    //get "lang" from context, default is "en"
    var lang string
    if v := ctx.Input.Header("lang"); v != "" {
		lang = v
	} else {
        lang = "en"    
    }

    msg := ErrorMsg(code, lang)
	params := map[string]interface{}{
		"code":   code,
		"msg":    msg,
		"result": result,
	}

	ctx.Output.JSON(params, false, false)
}
`
	if config["need_response_func"] == "1" {
		content += responseFunc
	}
	err = ioutil.WriteFile(OUT_PATH+ERROR_FILE, []byte(content), os.ModePerm)
	if err != nil {
		fmt.Printf("write to  %s failed : %v", OUT_PATH+ERROR_FILE, err)
		return
	}

	err = ioutil.WriteFile(config["md"]+"_"+MD_FILE, []byte(mdContent), os.ModePerm)
	if err != nil {
		fmt.Printf("write to  %s failed : %v", OUT_PATH+config["package"]+MD_FILE, err)
		return
	}

}
